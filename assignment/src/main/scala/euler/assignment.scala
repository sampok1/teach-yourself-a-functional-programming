package euler

object ProjectEuler {
  /*
   * Even Fibonacci numbers
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous
   * two terms. By starting with 1 and 2, the first 10 terms will be:
   *
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   *
   * By considering the terms in the Fibonacci sequence whose values do not
   * exceed four million, find the sum of the even-valued terms.
   */
  def problem2(): Int = countNext(2, 1, 0)

  def countNext(current: Int, prev: Int, sum: Int): Int = {
    if ((current) > 4000000) {
      sum
    } else {
      if ((current) % 2 == 0) {
        countNext(current + prev, current, current + sum)
      } else {
        countNext(current + prev, current, sum)
      }
    }
  }


  /*
   * Largest palindrome product
   *
   * A palindromic number reads the same both ways. The largest palindrome made
   * from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   *
   * Find the largest palindrome made from the product of two 3-digit numbers.
   *
   */
  def problem4(): Int = check4(999)

  def validate(value: Int, divider: Int): Boolean = {
    if (divider < 100) {
      false
    } else if (value % divider == 0 && value / divider < 1000 && value / divider > 99 ) {
      true
    } else {
      validate(value, divider -1)
    }
  }
  def check4(current: Int): Int = {
    if (current < 100) {
      -1
    } else if (validate((current.toString + current.toString.reverse).toInt, 999)) {
      (current.toString + current.toString.reverse).toInt
    } else {
      check4(current - 1)
    }
  }

  /*
   * Special Pythagorean triplet
   *
   * A Pythagorean triplet is a set of three natural numbers, 0 < a < b < c, for
   * which, a^2 + b^2 = c^2
   *
   * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   *
   * a = k(m^2 - n^2)
   * b = k(2mn)
   * c = k(m^2 + n^2)
   *
   * m > n
   *
   */
  def problem9(): Int = findPyttisProduct(1000)

  def findPyttisProduct(targetRound: Int): Int = {
    def a(m: Int, n: Int, k: Int): Int = k * ((m * m) - (n * n))
    def b(m: Int, n: Int, k: Int): Int = k * (2 * m * n)
    def c(m: Int, n: Int, k: Int): Int = k * ((m * m) + (n * n))

    def eval(m: Int, n: Int, k: Int, prevK: Int): Int = {
      val current = a(m, n, k) + b (m, n, k) + c(m, n, k)

      if (current == targetRound) {
        a(m, n, k) * b (m, n, k) * c(m, n, k)
      } else if (current > targetRound) {
        if (k == 1) {
          val mn = findNextM(n, n + 1)
          if (prevK == 1) {
            return 0
          }
          eval(mn._1, mn._2, 1, k)
        } else {
          val mn = findNextM(m, n)
          eval(mn._1, mn._2, 1, k)
        }
      } else {
        eval(m, n, k +1, k)
      }
    }

    def findNextM(m: Int, n: Int): (Int, Int) = {
      def checkMNCoPrime(m: Int, n: Int, i: Int): Boolean = {
        if (i > n) {
          true
        } else if (m % i == 0 && n % i == 0) {
          false
        } else {
          checkMNCoPrime(m, n, i + 1)
        }
      }

      if (checkMNCoPrime(m +1, n, 2)){
        (m + 1, n)
      } else {
        findNextM(m + 1, n)
      }
    }

    eval(2, 1, 1, 0)
  }




  /*
   * Maximum path sum I
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *   3
   *   7 4
   *   2 4 6
   *   8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom of the given triangle with 15
   * rows:
   */
  def problem18(triangle: List[List[Int]]): Int = bestRouteSum(triangle.init, triangle.last)

  /*
   * Maximum path sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom in the given triangle with
   * one-hundred rows.
   *
   * NOTE: This is a much more difficult version of Problem 18. It is not
   * possible to try every route to solve this problem, as there are 2^99
   * altogether! If you could check one trillion (10^12) routes every second it
   * would take over twenty billion years to check them all. There is an
   * efficient algorithm to solve it. ;o)
   */
  def problem67(triangle: List[List[Int]]): Int = bestRouteSum(triangle.init, triangle.last)

  def bestRouteSum(data: List[List[Int]], base: List[Int]): Int = {
    def getNewBase(currentRow: List[Int], baseTail: List[Int], prevFromBase: Int, target: List[Int]): List[Int] = {
      if (currentRow.isEmpty) {
        target.reverse
      } else {
        getNewBase(currentRow.tail, baseTail.tail, baseTail.head, Math.max(baseTail.head, prevFromBase) + currentRow.head :: target)
      }
    }
    if (data.isEmpty) {
      base.head
    } else {
      bestRouteSum(data.init, getNewBase(data.last, base.tail, base.head, List[Int]()))
    }
  }
}
